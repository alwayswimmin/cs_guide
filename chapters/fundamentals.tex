\chapter{Fundamentals}

\section{Input and Output}

The first part of solving any programming contest problem is reading the input correctly. In this section, we go over input and output in Java using \texttt{java.util.Scanner} and \texttt{java.io.PrintWriter}. There are two scenarios that you should be familiar with: \texttt{stdin}/\texttt{stdout} and file I/O. You encounter the former when you enter input and see output for a program run in the command line. You encounter the latter when you have two files (for example \texttt{input.txt} and \texttt{output.txt}) that you read from and write to.

When using \texttt{stdin}/\texttt{stdout}, we read input from \texttt{System.in} using a Scanner and output our results using \texttt{System.out.println()}. \texttt{Scanner.nextInt()} and \texttt{Scanner.next()} read in integers and strings, respectively. \texttt{System.out.println()} prints its argument and adds a newline at the end. (If we don't want the newline, we can use \texttt{System.out.print()}.) Here's an example of a main method that takes two integers and outputs their sum:

\begin{mylstlisting}
public static void main(String args[]) {
  // hint: you should write "import java.util.*;" at the top of your code.
  Scanner sc = new Scanner(System.in);
  int x = sc.nextInt();
  int y = sc.nextInt();
  System.out.println(x + y);
}
\end{mylstlisting}

File I/O is a touch more complicated. For our Scanner, we have to make a new File object and use it in the constructor. We do the same for our PrintWriter. However, PrintWriter also comes with a couple more usage notes. First, we should include \texttt{throws IOException} after our main method, since Java requires that we acknowledge the possibility of an IOException. (We bravely assume that our file open will succeed!) After we finish printing, we must also close the PrintWriter to make sure that everything gets written. Here's a snippet showing how Scanner and PrintWriter work with files: 

\begin{mylstlisting}
public static void main(String args[]) throws IOException {
  // hint: for file I/O, you should also have "import java.io.*;"
  Scanner sc = new Scanner(new File("input.txt"));
  int x = sc.nextInt();
  int y = sc.nextInt();
  PrintWriter pw = new PrintWriter(new File("output.txt"));
  pw.println(x + y);
  pw.close();
}
\end{mylstlisting}

Although more efficient methods of I/O exist, such as BufferedReader and BufferedWriter, what's covered here should be sufficient for now. (It's possible to read in $10^5$ integers with Scanner in a fraction of a second.)

\section{Complexity}

Before we start computing contests, we should understand what the problems on these contests are trying to test. One class of problems, called \emph{implementation problems}, assesses your ability write code quickly and accurately. These problems are only common in easier contests, since they usually don't involve too much thinking or creativity---you just have to implement what's written in the problem statement. Most competitive programming problems ask you to come up with a clever algorithm instead, testing speed and memory efficiency.

To analyze the efficiency of algorithms, computer scientists use a concept called \emph{complexity}. Complexity is measured as a function of the input size; an algorithm could require $3n$, $n^4/3$ or even $2^n + n^2$ steps to finish calculating for an input of size $n$. To express complexity, we use something called ``big-O notation.'' Essentially, we write the number of steps it takes for an algorithm to finish inside a pair of parentheses with an $O$ in front, like this: $O(\text{\# of steps})$. However, we drop any constant factors and lower order terms from the expression.\footnote{Actually, this isn't entirely accurate. Saying an algorithm is $O(f(n))$ really means it takes \emph{at most} $c\cdot f(n)$ steps to finish, for a sufficiently large constant $c$.} I'll explain why in a moment; let's look at some examples for now. 

Suppose we have three programs that require $3n$, $n^4/3$ and $2^n + n^2$ steps to finish, respectively. The complexity of the first program is $O(n)$ because we don't care about the constant factor $3$ on the $3n$. The complexity of the second program is $O(n^4)$; again, we drop the constant. For the last program, we write its complexity as $O(2^n)$ because $n^2$ is a lower order term.

As to why we drop the constants and the lower order terms, consider the first two programs from above. When $n=300$, the first program takes $900$ steps, while the second program takes $2,700,000,000$ steps. The second program is much slower, despite a smaller constant factor. Meanwhile, if we had a third program that runs in $5n$ steps, it would still only take $1,500$ steps to finish. Constant factors become pretty much irrelevant when we're comparing functions that grow at different rates. The same can be said about lower order terms: $n^2$ gets dwarfed by $2^n$ even when $n=10$.

Thus in programming contests, we usually want a program with the correct complexity, without worrying about too much constant factors. Complexity will be the difference between whether a program gets \textbf{\color{green}accepted} or \textbf{\color{red}time limit exceeded}. As a rule of thumb, a modern processor can do around $10^8$ computations each second. When you plug the maximum possible $n$ into the complexity of your algorithm, it should never be much more than that.

We've focused on time and haven't talked much about memory so far, but memory does gets tested. The amount of memory a program uses as a function of $n$ is called its \emph{space complexity}, as opposed to the \emph{time complexity} we discussed earlier. Space complexity however, shows up much less frequently than time complexity. One of the reasons is that you usually run out of time before you can exceed the memory limit.

\section{First Problems}

Now that you know the basics, let's get started by solving a few problems. Try to figure out a solution to each problem before reading our analysis. To test your code for the problems in this chapter, you should create an account on Codeforces. After you login, there will be an ``Introduction'' problem set available \href{http://codeforces.com/group/iMPx86rZXm/contests}{here} that includes these problems and a few extras.

\subsection{Bessie's Candles}

\texttt{
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
  Bessie is a romantic cow; she spends her evenings writing code in the warm glow of candlelight. In her barn, she currently has $a$ new candles, each of which burns for exactly one hour. Ever the efficient cow, Bessie can make a new candle from $b$ burnt out candles. Your task, given $a$ and $b$ ($2 \le a, b \le 1000$), is to help her figure out the maximum number of hours for which she can keep her barn illuminated. [Adapted from \href{http://codeforces.com/problemset/problem/379/A}{Codeforces 379A}.]
}

\texttt{Bessie's Candles} is a straightforward implementation problem. Since $a$ and $b$ are small, we can simulate Bessie's candle burning process. We track of the number of candles we have left, the number of burnt out candles, and the number of hours that have passed. Whenever we have more than $b$ burnt out candles, we make a new candle. Once we run out of candles, we print our answer.

\subsection{Froyo}

\texttt{
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
  Bessie has recently founded a froyo startup, offering froyo made from the best cows in Wisconsin. She has kept track of her profits for the first $n$ days ($1 \le n \le 10^5$) and knows that she earned $a_i$ dollars on the $i$th day. Growth is always important in startups, so Bessie wants to know the length of the longest non-decreasing subsegment in her profits. Help her figure this out! (Here, a subsegment denotes a contiguous block of numbers $a_i, a_{i+1}, \cdots, a_j$ ($i < j$).) [Adapted from \href{http://codeforces.com/problemset/problem/580/A}{Codeforces 580A}.]
}

Our first thought upon reading this problem might be to check each subsegment of the sequence $a_i$ and see if that subsegment is non-decreasing. Unfortunately, this is too slow. There are approximately $n^2/2$ pairs of endpoints that we could choose, far too many when $n$ can be up to $10^5$. (Remember that rule of $10^8$?) Instead, we can solve this problem with around $n$ steps by performing a single sweep through the array. We maintain a counter representing Bessie's currrent ``streak''---the number of days since her profit last decreased. If her profit decreases from day $i$ to day $i+1$, then we reset the counter to zero. The answer we report is the longest streak that we ever see.

\texttt{Froyo} is a clear example of how getting the right complexity is essential. Our initial idea, which could have been implemented in $O(n^3)$ or $O(n^2)$, was too slow. To make our program finish in time, we had to work out a more efficient alrogithm that ran in $O(n)$.

\section{Sorting}

To further explore the concept of complexity, we will use sorting algorithms as a case study. Sorting is just as it sounds---we're given a collection of objects, and we want to sort them into a predefined order. For example, suppose we have a list of scores from a programming contest. In order to generate the final standings, we'll need to sort the contestants into ascending order by score. Below, we present three classic sorting algorithms of varying complexity: insertion sort, merge sort and quicksort. To supplement our descriptions of the algorithms, you can check out the animations at \url{http://visualgo.net/sorting.html}.

In our last subsection, we discuss a problem that involves sorting as a subtask and go over how to sort in Java and C++.

\subsection{Insertion Sort}

Insertion sort builds up a sorted list by inserting new elements one at a time. Inserting an element into a sorted list takes time proportional to the length of the list, so the runtime of this algorithm is $1 + 2 + 3 + \cdots + n$, which is $O(n^2)$. One way to think about this is to iterate $i$ from $1$ to $n$, and let the first $i$ elements be our sorted list. To insert the $(i+1)$th element, we just swap it with the largest, the second largest, and so on, until it's greater than than the next largest element. Then we have a sorted list in the first $(i+1)$ entries of the array. Insertion sort, despite being slower than merge sort and quicksort, is still useful because of its efficiency on small inputs. Many implementations of merge sort and quicksort actually use insertion sort once the problem size gets small.

Around how long is the longest list that you can sort with insertion sort in less than a second?

\subsection{Merge Sort}

The idea behind merge sort is the following observation: If we are given two sorted lists of length $n/2$, we only need $n$ comparisons to merge them into one sorted list of length $n$. So we can divide and conquer. We do this by cutting the array in half, sorting each half recursively, and merging the two halves back together. Because our recursion goes $\log_2 n$ levels deep, this algorithm runs in $O(n \log n)$. Try to work out the details of this yourself. (You can in fact prove that $O(n \log n)$ comparisons is optimal for sorting algorithms, one of the few problems in computer science that has a non-trivial lower bound.)

Around how long is the longest list that you can sort with merge sort in less than a second?

\subsection{Quicksort}

Quicksort also uses a divide and conquer strategy to run in $O(n \log n)$ on average. We first take a random element from the array, called the \emph{pivot}. Then, we move anything less than the pivot to the left of the array, anything greater than the pivot to the right of the array, and recurse on the two halves that we just created. We say that quicksort runs in $O(n \log n)$ only on average because there are cases that can make quicksort run in $O(n^2)$. What would happen if we chose the smallest element of the array as the pivot each time?

Quicksort was previously used by Java's \texttt{Arrays.sort} and \texttt{Collections.sort}, but these functions now use dual-pivot quicksort and timsort.

\subsection{Ms. Manana's Puzzles}

\texttt{
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
  The end of the school year is near and Ms. Manana will soon have to say goodbye to a yet another class. As a farewell present, she decides to give each of her $n$ ($1\le n\le 50$) students a jigsaw puzzle. The shop assistant tells Ms. Manana that there are $m$ ($1\le m\le 50$) puzzles in the shop, but they differ in difficulty and size. Specifically, the first jigsaw puzzle consists of $f_1$ pieces, the second one consists of $f_2$ pieces, and so on. Ms. Manana doesn't want to upset the children, so she wants the difference between the numbers of pieces in her largest puzzle and her smallest puzzle to be as small as possible. Can you help Ms. Manana find this minimum difference? [Adapted from \href{http://codeforces.com/problemset/problem/337/A}{Codeforces 337A}.]
}

We solve this problem by first sorting the sequence $f_i$. After sorting, Ms. Manana will want to buy puzzles from a contiguous block of the sequence. (If she doesn't, then the difference between the largest and smallest puzzles will be greater than necessary.) Thus we can iterate through the sorted sequence to find the minimum difference between the endpoints of length $n$ blocks.

Usually, when solving a sorting problem, we don't need to implement our own sorting function. If you're using Java, \texttt{java.utils.Arrays} has a function \texttt{Arrays.sort} that does the magic for you. In C++, you can add \texttt{\#include <algorithm>} to your header and use \texttt{std::sort}. When coding this problem, try to use the builtin-in sort function in your language.

Here are code snippets for sorting an array \texttt{arr} of length \texttt{n} in Java and C++, respectively:

\begin{mylstlisting}
// hint: you should have "import java.util.*;" at the top of your code.
int[] arr = new int[n];
// do something to fill up the array.
Arrays.sort(arr);
\end{mylstlisting}

\begin{mylstlisting}
// hint: you should have "#include <algorithm>" at the top of your code.
int arr[n];
// do something to fill up the array.
std::sort(arr, arr + n);
\end{mylstlisting}
